# 微信小程序云开发

## 云开发注册、项目初始化

- 每个环境相互隔离，拥有唯一的**环境 ID**，包含独立的数据库实例、存储空间、云函数配置等资源；
- 初始创建的环境自动成为**默认环境**；
- 腾讯云控制台创建的云开发环境也可在微信云开发中使用。登录微信云开发控制台-设置-环境设置，点击环境名称，选择“管理我的环境”，点击“使用已有腾讯云环境”按钮，选择所需腾讯云环境，即可在微信云开发控制台使用该环境。

（来自官方文档）

## 数据库

### 使用云控制台控制数据库

+ 开发界面中点击“云开发”->进入云开发控制台

+ 数据库->增加集合->添加记录（类似json数据）->一个记录类似一个对象，一个集合就是所有对象的集合



（以下内容摘自官方文档：）

云开发提供了一个 JSON 数据库，顾名思义，数据库中的每条记录都是一个 JSON 格式的对象。一个数据库可以有多个集合（相当于关系型数据中的表），集合可看做一个 JSON 数组，数组中的每个对象就是一条记录，记录的格式是 JSON 对象。

关系型数据库和 JSON 数据库的概念对应关系如下表：

| 关系型          | 文档型            |
| :-------------- | :---------------- |
| 数据库 database | 数据库 database   |
| 表 table        | 集合 collection   |
| 行 row          | 记录 record / doc |
| 列 column       | 字段 field        |

### 数据库操作

#### 页面引入数据库（初始化）

在js文件头部增加

```javascript
const db=wx.cloud.database();
```

注意这里建议用const，因为这个值正常不改了

#### 调用数据库数据

##### 获取一个集合的数据：

```javascript
db.collection(collectionName).get()
```

可以获得集合collectionName中的所有对象的数组：

```javascript
db.collection(collectionName).get({
    success:res=>{
        //do something with res, like:
        console.log(res.data);
    }
})
```

<mark>注意：这里第一次用的时候get在控制台中打印不出任何东西，因为没有开权限。具体为云开发控制台->数据库->管理权限，设置为所有人可读，创建者可写</mark>

也可以用Promise风格调用：

```javascript
db.collection('todos').get().then(res => {
  // res.data 是一个包含集合中有权限访问的所有记录的数据，不超过 20 条
  console.log(res.data);
})
```

注意2：这里res似乎是一个包含两个元素的对象，一个是data对应的数组（即集合里所有数据对象的集合），另一个是errMsg（暂时不知道是什么）

##### 增加doc(_id)可以调用集合中特定id的对象：

```javascript
db.collection(collectionName).doc(_id).get()
```

如：

```
db.collection('demoList').doc('f624ef4065570be602d8ec387b60ff51').get().then(
      res=>{
        console.log(res.data);
      }
)
```

##### 注意事项

(摘自官方文档)为了防止误操作以及保护小程序体验，小程序端在获取集合数据时服务器一次默认并且最多返回 20 条记录，云函数端这个数字则是 100。开发者可以通过 `limit` 方法指定需要获取的记录数量，但小程序端不能超过 20 条，云函数端不能超过 100 条。

##### 完整案例：按按钮从数据库调数据到data中，将data打印在页面上

```html
<!--wxml-->
<button type="primary" bind:tap="getData">点击获取数据</button>
<view wx:for="{{dataObj}}">{{item}}</view>  <!--遍历所有dataObj中的字段并打印-->
```

```javascript
//js
const db=wx.cloud.database();
Page({
  data: {
    dataObj:"",
  },
  getData(){
    db.collection('demoList').doc('f624ef4065570be602d8ec387b60ff51').get().then(
      res=>{
        this.setData({
          dataObj:res.data,
        })//本地数据赋值的语句
      }
    )
  },
})
```

##### 用where来获取特定key下满足特定条件的所有记录

```javascript
//index.js
const db=wx.cloud.database();
Page({
  data: {
    testArr:['a','b','c','d','e'],
    dataObj:"",
  },

  getData(){
    db.collection('demoList').where({
      "author": "中关村在线"
    }).get().then(
      res=>{
        console.log(res.data);
        this.setData({
          dataObj:res.data,
        })
      }
    )
  }
})
```

这样res.data就是所有满足where中定义条件的对象的**数组**，这和doc是不一样的。因为id和对象是一一对应关系，而where是筛选满足一定条件的对象

+ **where中参数的设计：**

（以下内容粘贴自微信官方文档）

假设我们需要查询进度大于 30% 的待办事项，那么传入对象表示全等匹配的方式就无法满足了，这时就需要用到查询指令。数据库 API 提供了大于、小于等多种查询指令，这些指令都暴露在 `db.command` 对象上。比如查询进度大于 30% 的待办事项：

```js
const _ = db.command
db.collection('todos').where({
  // gt 方法用于指定一个 "大于" 条件，此处 _.gt(30) 是一个 "大于 30" 的条件
  progress: _.gt(30)
})
.get({
  success: function(res) {
    console.log(res.data)
  }
})
```

API 提供了以下查询指令：

| 查询指令 | 说明                 |
| :------- | :------------------- |
| eq       | 等于                 |
| neq      | 不等于               |
| lt       | 小于                 |
| lte      | 小于或等于           |
| gt       | 大于                 |
| gte      | 大于或等于           |
| in       | 字段值在给定数组中   |
| nin      | 字段值不在给定数组中 |

更多具体的查询指令 API 文档可参考[数据库 API 文档](https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-sdk-api/database/Command.html)。

+ 逻辑指令：

除了指定一个字段满足一个条件之外，我们还可以通过指定一个字段需同时满足多个条件，比如用 `and` 逻辑指令查询进度在 30% 和 70% 之间的待办事项：

```js
const _ = db.command
db.collection('todos').where({
  // and 方法用于指定一个 "与" 条件，此处表示需同时满足 _.gt(30) 和 _.lt(70) 两个条件
  progress: _.gt(30).and(_.lt(70))
})
.get({
  success: function(res) {
    console.log(res.data)
  }
})
```

#### 向数据库插入数据

db.collection(collectionName).add({})

例：点击按钮向数据库demoList中添加数据，添加成功后打印res

```html
<!--wxml-->
<button type="primary" bind:tap="addData">插入数据</button>
```



````javascript
// pages/index/index.js
const db=wx.cloud.database();
Page({
  data: {
    testArr:['a','b','c','d','e'],
    dataObj:"",
  },
  addData(){
    db.collection("demoList").add({
      data:{
        title:"测试标题1",
        author:"测试作者1",
        content:"测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1",
        tags:[
          "tag1",
          "tag2",
          "tag3",
        ]
      }
    }).then(
      res=>{
        console.log(res);
      }
    )
  }
})
````

还可以在上传数据的过程中让用户界面不能操作：

需要将addData()方法改为：

```javascript
addData(){
    wx.showLoading({
      title: '插入数据中',
    });//在用户屏幕上显示'插入数据中'的加载图标
    db.collection("demoList").add({
      data:{
        title:"测试标题1",
        author:"测试作者1",
        content:"测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1测试内容1",
        tags:[
          "tag1",
          "tag2",
          "tag3",
        ]
      }
    }).then(
      res=>{
        console.log(res);
        wx.hideLoading();//上传成功，停止加载
      }
    )
}
```

##### 提交表单到数据库

```html
<!--wxml-->
<form bindsubmit="btnSub">
  <input name="title" class="testInput" placeholder="请输入标题"></input>
  <input name="author" class="testInput" placeholder="请输入作者"></input>
  <textarea name="content" class="testInput" placeholder="请输入内容"></textarea>
  <button type="primary" form-type="submit">提交</button>
</form>
<!--这是一个做好的表单+提交按钮组合-->
```

接下来写btnSub()函数触发后的逻辑：

btnSub()的参数res是一个很大的对象（有很多系统给的参数等），其中res.detail.value才是我们输入的所有值的集合构成的对象

最终btnSub()被写作如下：

```javascript
btnSub(res){
  let title=res.detail.value.title;
  let author=res.detail.value.author;
  let content=res.detail.value.content;
  db.collection("demoList").add({
    data:{
      title:title,
      author:author,
      content:content,
    }
  }).then(res=>{
    console.log(res);
  })
},
```

这样，每点击按钮就会提交表单中的数据一次，并且成功后控制台打印出来

#### 更新数据库中的数据

##### update的用法

用collection(collectionName).where()或collection(collectionName).doc(_id)来选中特定对象，后加update({data:{}})进行修改

注意：collection(collectionName)只是获取整个集合，后面不能直接加update（这样把整个集合的某个键对应的值都改了）

+ 下面展示点击按钮将特定id的记录的author修改的案例：

```html
<!--wxml-->
<button type="primary" bind:tap="updateData">更新一条记录</button>
```

```javascript
//js
const db=wx.cloud.database();
Page({
  updateData(){
    db.collection("demoList").doc("41d77edc6559d4710a71b6f57ac7e49c").update({
      data:{
        author:"王进",
      }
    })then(res=>{
        console.log(res);
    })
  }
})
```

注意：对于更新，where只有在云函数端才能用

另外，可以在update中增加之前没有的键值对，而非只能修改原有键的值

##### set的用法

set和update的不同点在于，set设置的对象会将原有的整个对象覆盖，而非只修改/增加键值对

将上述例子改成set后：

原数据库的这条对象记录变为：

```json
{"_id":"41d77edc6559d4710a71b6f57ac7e49c","author":"王进","_openid":"o2hKy65TeZMSK_xcbbAg5MoGceg8"}
```

除了系统自带的部分，只保留author: "王进"

#### 数据库删除数据

删除操作十分简单，用常规的collection(collectionName).doc(id)获取对应数据后.remove()即可删除

```javascript
deleteData(){
	db.collection("demoList").doc("41d77edc6559d4710a71b6f57ac7e49c").remove().then(res=>{
  		console.log(res);
	});
},
```

#### count()--统计数据条数

```javascript
countData(){
  db.collection("demoList").count().then(res=>{
  	console.log(res);
  })
}
```

每次调用在控制台上打印demoList集合里对象的个数

#### watch()监听

每次数据库产生变化会调用相应函数





















